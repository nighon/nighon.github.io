---
layout: "post"
title: "Python 的垃圾回收机制"
---

在 Python 中，垃圾收集是解释器自动释放不再使用的内存的过程，从而使其可用于将来的分配。Python 主要使用一种称为引用计数的技术进行垃圾收集，并结合循环垃圾收集器来处理更复杂的循环引用。

## 引用计数 (Reference Counting)：

这是 Python 中主要的垃圾收集机制。Python 中的每个对象都包含一个引用计数，它跟踪指向该对象的引用数量。当一个对象的引用计数降至零时，意味着不再有对该对象的引用，Python 的垃圾收集器会自动释放与该对象关联的内存。

## 循环垃圾收集器 (Cyclic Garbage Collector)：

尽管有引用计数，循环引用仍然会导致内存泄漏，因为对象可以在循环中相互引用，从而防止它们的引用计数达到零。Python 的循环垃圾收集器识别并回收此类循环引用。它定期扫描堆中是否存在循环引用的对象，如果程序的其余部分无法再访问它们，则释放它们。

## 堆 (Heap)

> 在 Python中，堆是指发生动态内存分配的内存区域。当你在 Python 中创建对象时，它们会在堆上分配内存空间。这是 Python 的内存管理系统跟踪对象及其关联数据的地方。
>
> Python 中的堆由 Python 内存分配器管理，它处理内存分配和释放的请求。内存分配器跟踪空闲内存块，为新对象分配内存，并在对象不再使用时释放内存。

Python 的垃圾收集器在该堆中运行，定期扫描它以识别程序不再可访问的对象。这包括引用计数为零的对象以及无法从程序的其余部分访问的循环引用。当垃圾收集器识别出此类对象时，它会释放与它们关联的内存，使其可用于将来的分配。

## 循环引用 (Cyclic references)

当对象以循环方式相互引用时，就会发生循环引用，形成引用循环。这些循环引用可以防止对象的引用计数降至零，这通常会触发垃圾收集器释放它们。因此，如果处理不当，循环引用可能会导致内存泄漏。

Python 的垃圾收集器包含一种识别和处理循环引用的机制。它的工作原理如下：

**可达性分析 (Reachability Analysis)：**Python 的垃圾收集器定期从根对象开始执行可达性分析。根对象是那些可以从执行上下文直接访问的对象，例如全局变量、局部变量和调用堆栈上的对象。

**标记和清除 (Mark and Sweep)：**在可达性分析期间，垃圾收集器标记所有可达对象。它从根对象开始，遍历对象图，将遇到的每个对象标记为可达。在此遍历期间未标记的对象被认为是不可访问的并且可以被释放。

**处理循环引用 (Handling Cyclic References)：**当垃圾收集器遇到循环引用时，如果无法从任何根对象访问它们，它仍然可以将它们识别为不可访问。即使循环内的对象相互引用，如果程序的其余部分无法访问它们，则它们将被视为无法访问并有资格释放。

**释放 (Deallocation)：**一旦垃圾收集器识别出无法访问的对象，它就会释放它们的内存，为将来的分配释放资源。

## 什么是“无法访问”？

在 Python 中的垃圾收集和内存管理上下文中，术语“无法访问 (unreachable)”并不是专门指变量范围。相反，它指的是 Python 程序无法从其执行上下文的任何部分访问或到达的对象。对象是否可达或不可达取决于是否存在可从程序的执行上下文访问的任何引用。

这是更准确的解释：

**可到达性：**如果可以通过程序执行上下文中任何根对象的引用来访问或到达某个对象，则该对象被认为是可到达的。根对象包括全局变量、当前执行的函数或方法中的局部变量以及调用堆栈上的对象。

**不可访问性：**如果程序执行上下文中的任何根对象都没有对某个对象的引用，则该对象被视为不可访问。这意味着程序无法访问或到达该对象，即使它可能仍然存在于内存中。

对于在循环或函数内定义的对象，它们的可达性取决于是否存在超出循环或函数范围的对它们的引用。如果在循环或函数之外没有对这些对象的引用，则假设没有其他对它们的引用，一旦循环或函数退出，它们可能会变得不可访问。

需要注意的是，Python 的垃圾收集器会自动识别和释放无法访问的对象，无论它们是在哪里定义的或最后在哪里引用的。这有助于释放内存并防止Python程序中的内存泄漏。

## 最后

值得注意的是，虽然 Python 通过垃圾回收自动管理内存，但如果引用管理不当，仍然可能会造成内存泄漏，特别是在长时间运行的应用程序或处理大型数据结构时。因此，开发人员了解 Python 的内存管理并确保对象在不再需要时得到正确释放非常重要。当不再需要对象时，使用 del 语句显式删除它们。

